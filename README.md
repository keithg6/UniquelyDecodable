TO RUN:
To run this program, one can either open the file in Visual Studio or run it from the command line. To run this program from the command line, one must have a C# compiler installed. Once you have a C# compiler, save the source code into a file titled UniquelyDecodable.cs, then navigate to the location where you saved this file on the command line. Then, in quotation marks, type the location of your C# compiler followed by UniquelyDecodable.cs. The location my compiler was in was "C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\MSBuild\15.0\Bin\Roslyn\csc.exe", so my command was "C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\MSBuild\15.0\Bin\Roslyn\csc.exe" UniquelyDecodable.cs. After running this command, a .exe file will be stored in the same location as your .cs file. You can then just type the name of the file, which would be UniquelyDecodable.

DETAILED EXPLANATION:
This program uses hashsets to store the different values for Cn and recursion to repeatedly compute the values for Cn+1. The program asks the user to input values for C then stores those values in a hashset. The computation all occurs in the method, “compute(C, C1)”. The first call of the method uses C for both C and C1, and from there computes the next C. This is done by checking to see if any values from C1 are contained within any other values from C, and adding said values to a hashset. After checking all values, the program checks to see if these values have been found in previous C’s, because if so, the program can determine C∞. This is the break condition so that the program does not get stuck in an infinite loop of recursion. If these values are not found in a previous C, the program adds these values to c∞ and makes a recursive call to compute the next C. I used hashsets so that there are no repeating values. After the break condition is encountered, the program creates a new hashset that is the intersection of C∞ and C. If the hashset is empty, we know that C is uniquely decodable. If the hashset is not empty, it will print all the values that are contained in both C and C∞.

For an example, if I ran the program and entered the values 0 01 011, it would store these values in C. Compute would be called, and would check each value against one another. Since 0 is in C and 0.1 = 01 which is also in C, it would create a substring containing the “1” and store it in the hash set. Since 0 is in C and 0.11 = 011 which is also in C, it would store a substring containing 11 in the hashset. Then, the program checks to see if these values have been found for a previous C by checking the hashset called “values.” These values are not in the hashset so it stores the values in the “values” and calls compute again but now with C containing 0, 01, 011 and Cn containing 1 and 11. Compute checks the values against each other again, but finds that there are no values for v such that u+v=w where u is in Cn and w is in C, so the new Cn+1 is empty. Therefore, compute returns the final values for C∞ and creates a hashset for the intersection of C and C∞. This hashset is empty, so C is uniquely decodable.
